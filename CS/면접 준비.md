- 트랜잭션

한 번에 수행되어야할 일련의 연산 모음

모두 완벽하게 처리하거나, 처리하지 못할 경우 원 상태로 복구

<br/>

- 트랜잭션 4가지 특징 (ACID)

1. 원자성 : 트랜잭션이 DB에 모두 반영되거나, 반영되지 않아야 한다.

2. 일관성 : 트랜잭션 작업 처리 결과가 항상 일관성이 있어야 한다.

3. 독립성 : 어떤 트랜잭션이 다른 트랜잭션의 연산에 낄 수 없다.

4. 지속성 : 결과는 영구적으로 반영된다.

<br/>

- HTTP

텍스트 기반 통신 규약

<br/>

- REST Api

 자원을 기반으로 자원의 상태를 주고받음

 무상태성의 특징 : 각 요청이 독립적이며 서버가 클라이언트의 상태를 저장하지 않음

 <br/>

 - TCP / IP

IP는 패킷이라는 통신 단위로 지정된 IP 주소의 목적지에 보냄

TCP는 연결 지향형 프로토콜, 신뢰성 보장

<br/>

- TCP / IP 4계층

1. 네트워크 인터페이스 계층

노드 간의 데이터 전송 담당. 알맞은 하드웨어로 데이터가 전달되도록

2. 인터넷 계층 - IP

IP를 사용해 데이터의 목적지로, 빠르게 도착

3. 전송 계층 - TCP / UDP

4. Application 계층 (HTTP / FTP)

서버나 클라이언트 응용 프로그램이 동작하는 계층

<br/>

- Kafka

카프카는 높은 처리량의 분산 이벤트 스트리밍 플랫폼

pub-sub 형태의 메시지큐로 동작. broker들이 하나의 클러스터로 구성되며 주키퍼에 의해 관리.

rabbitmq 대신 사용은 msa 환경에서 여러 서비스 간 데이터 전송이 일어날 때, 높은 처리량. 그리고 시스템 장애 시 메시지 복구 가능

3개의 클러스터 : 카프카 브로커의 장애로 데이터 손실 -> 3개의 브로커를 구성해 장애 발생 시 다른 브로커로 전환되도록.

<br/>

- telegraf

필요한 데이터 뿐만 아니라 cpu, 메모리, 디스크 등 필요한 데이터를 수집하기 위해 사용

<br/>

- docker

컨테이너 기반 가상화 기술

빌드, 공유, 실행

<br/>

- 보상적 트랜잭션

MSA 환경에서 다른 서비스로 kafka 이벤트를 이용해 요청. 분산 환경이므로 실패 시 트랜잭션 롤백 불가

SAGA 패턴 적용 - 실패 시 보상 이벤트를 발행해 데이터 일관성 보장

<br/>

- redis 분산 락

동시성 문제 : 한 공유 자원에 여러 스레드가 동시 접근하며 발생하는 문제.

단일 환경에서는 비관적 락을 사용 - > 분산 환경으로 변경하며 분산 락 사용


<br/>

- ConcurrentHashMap

HashMap 에는 synchronized 키워드가 존재 안함.

ConcurrentHashMap에는 put 메소드 중간에 synchronized 키워드가 존재 쓰기 작업 시 lock 을 사용해서 동시성 문제 해결됨

<br/>

- WebSocket

웹에서 클라이언트와 서버 간 양방향 통신을 가능하게 하는 프로토콜. HTTP 기반으로 지속적인 연결 유지

stomp 프로토콜은 메시지 시스템을 위한 간단한 텍스트 기반 프로토콜

pub/ sub 구조.

<br/>

- CDN 컨텐츠 전송 네트워크

웹 콘텐츠 (이미지, 비디오 등)를 사용자에게 빠르고 효율적으로 전달하기 위해 설계된 분산형 네트워크 서비스.

사용자와 가장 가까운 서버에서 컨텐츠를 제공 -> 로딩 속도 향상

자주 요청되는 컨텐츠는 캐싱 

동적 가속 : 동적 웹 컨텐츠 같은 경우 캐싱이 제대로 작동하지 않을 수 있어서 CDN 서버에서 오리진 서버와의 연결을 최적화

<br/>

- CI / CD

CI (Continuous Integration)는 지속적인 통합으로, 애플리케이션의 새로운 코드 변경 사항이 정기적으로 빌드 및 테스트되어 공유 레포지토리에 통합하는 것을 의미합니다.
따라서 CI의 목표는 여러 명이 Git과 같은 관리 툴을 사용하는 환경에서 자동화된 빌드와 테스트를 통해 소스 코드의 충돌을 방지하여 소프트웨어의 품질을 개선하고, 릴리즈의 시간을 단축시키는 것에 있습니다.

CD (Continuous Delivery & Continuous Deployment)는 지속적인 서비스 제공 혹은 지속적인 배포로, 여기서 지속적인 제공이란 변경 사항이 공유 레포지토리로 자동으로 업로드 되는 것을 의미하고, 지속적인 배포란 변경 사항을 레포지토리에서 고객이 사용 가능한 프로덕션 환경까지 자동으로 릴리스하는 것을 의미합니다.

CI/CD를 통해 빌드, 테스트 그리고 배포까지 자동화를 시켜 노력을 단축시킬 수 있는 장점을 얻을 수 있습니다.

<br/>

- proxy vs reverse proxy

proxy server 는 클라이언트와 서버간의 중계 서버, 통신을 대리 수행

캐시, 보안, 트래픽 분산 등의 장점을 갖는다.

forward proxy 

클라이언트와 인터넷 사이 위치

클라이언트가 요청한 내용을 캐싱 → 외부요청 감소 - 네트워크 병목 현상 방지 , 전송 시간 절약. 

익명성 클라이언트가 보낸 요청을 server 에서 알 수 없음.

reverse proxy

서버와 인터넷 사이 위치 - 보통 기업 네트워크 환경에서 내부/외부네트워크 사이에 위치하는 구간을 DMZ 

실제 서비스 서버는 내부망에 위치

캐싱

보안 - 서버 정보를 클라이언트로부터 숨김

<br/>

- 컨텍스트 스위칭

한 task가 끝날 때까지 기다리지 않고 여러 작업을 번갈아 가며 실행.

<br/>

- 동기 비동기 블로킹 논블로킹

1. 동기 / 비동기 : 요청 작업에 대해 완료 여부를 신경써 작업을 순차적으로 수행할지 아닌지

동기 : 메서드 리턴과 결과를 전달받는 시간이 일치

비동기 : 요청 작업에 대해 완료 여부를 따지지 않고 다음 작업 수행

2. 블로킹 / 논블로킹 : 현재 작업이 대기되는지 아닌지

블로킹 : 대상 작업이 끝날때 까지 대상이 제어권을 가지고 있는것

논블로킹 : 대상 작업 완료 여부와 상관없이 새로운 작업 수행

<br/>

- 메타데이터

시간이 지남에 따라 많은 양의 데이터 수집, 저장, 분석 할 수 있도록 일관되게 구조화된 데이터로, 다른 데이터를 설명해줌.

<br/>

- 데이터 거버넌스

데이터 생성부터 수집, 저장, 분석 등에 대한 총체적인 관리 프로세스. 보호, 보안 등까지

<br/>

- N + 1

JPA 사용 시 연관 관계가 설정된 엔티티를 조회할 경우 조회된 데이터 갯수만큼 조회 쿼리가 추가로 발생

이유 : JPA가 JPQL을 분석해서 SQL 생성 시 오직 JPQL 자체만을 사용하므로 (Fetch 전략이 아닌)

즉시 로딩일 경우 : 전체 조회 시 영속성 영속성 컨텍스트가 아닌 DB에서 직접 데이터를 조회한 다음 관련 테이블 모두 조회

지연 로딩일 경우 : 하위 엔티티 로드 시 영속성 컨텍스트에 없다면 추가적인 조회 쿼리 발생 

해결법 : Fetch Join, @EntityGraph 사용, BatchSize를 이용해 전체적인 batch size 조절

